# 题目 01- 完成 ReadView 案例，解释为什么 RR 和 RC 隔离级别下看到查询结果不一致
## 案例 01- 读已提交 RC 隔离级别下的可见性分析

- 目标：通过分析的ReadView，理解RC隔离级别下不同事务间操作的可见性

- 操作步骤

  | 时间 | Tx1                         | Tx2                           | Tx3                      |
  | ---- | --------------------------- | ----------------------------- | ------------------------ |
  | T1   | begin;                      | begin;                        | begin;                   |
  | T2   | name = '关羽' WHERE id = 1; |                               |                          |
  | T3   | name = '张飞' WHERE id = 1; |                               |                          |
  | T4   |                             | name = '赵云' WHERE id = 1;   |                          |
  | T5   |                             | name = '诸葛亮' WHERE id = 1; |                          |
  | T6   |                             |                               | SELECT ... WHERE id = 1; |
  | T7   | commit;                     |                               |                          |
  | T8   |                             |                               | SELECT ... WHERE id = 1; |
  | T9   |                             | commit;                       |                          |
  | T10  |                             |                               | SELECT ... WHERE id = 1; |

- 实践过程

  - 创建表（略）
  - 设置隔离级别：`set session transaction isolation level read committed;`
  - 启动3个事务
  - Tx1 update；
  - Tx2 update，由于Tx1锁未释放，所以会等待
  - Tx3 查询，由于Tx1未提交，所以结果是【刘备】
  - Tx1 提交，Tx3查询，结果是【张飞】
  - Tx2 提交，Tx3查询，结果是【诸葛亮】
  - Tx3 提交

- 结论

  - 在Tx3运行过程中，根据Tx1、Tx2是否提交状态的不同，读到的数据会发生变化，属于【不可重复读】
  - RC未能解决不可重复读问题，问题仍存在。

## 案例 02- 可重复读 RR 隔离级别下的可见性分析

- 目标：通过分析的ReadView，理解RR隔离级别下不同事务间操作的可见性
- 操作步骤：同案例1，但是设置`set session transaction isolation level read repeated;`
- 实践过程
  - 创建表（略）
  - 设置隔离级别：`set session transaction isolation level read repeated;`
  - 启动3个事务
  - Tx1 update；
  - Tx2 update，由于Tx1锁未释放，所以会等待
  - Tx3 查询，结果是【刘备】
  - Tx1 提交，Tx3查询，结果是【刘备】
  - Tx2 提交，Tx3查询，结果是【刘备】
  - Tx3 提交

- 结论
  - 在Tx3运行过程中，读到的数据不会发生变化，不存在【不可重复读】
  - RR解决了不可重复读问题。


- 结论分析

  - ReadView是张存储事务id的表，主要包含当前系统中有哪些活跃的读写事务，把它们的事务id放到一个 列表中。结合Undo日志的默认字段【事务trx_id】来控制那个版本的Undo日志可被其他事务看见。

  - T6时刻，Undo日志版本链对应如下（简化）

    | TX    | name   |
    | ----- | ------ |
    | 11897 | 诸葛亮 |
    | 11897 | 赵云   |
    | 11896 | 张飞   |
    | 11896 | 关羽   |
    | xxxx  | 刘备   |

  - T6时刻，开启事务后发生了第一次select语句，生成ReadView。

    - 系统中活跃的读写事务id列表m_ids：11896、11897、72xxxx
    - m_low_limit_id最小事务id：11895
    - m_up_limit_id最大事务id：
    - m_creator_trx_id：72xxxx
    - 由于m_creator_trx_id非常大，
      - 查找不属于m_ids，且最大的tx_id，结果是tx_id=0，结果查出刘备

  - T8时刻，发生第二次select语句，生成ReadView。

    - 系统中活跃的读写事务id列表m_ids：2、3
    - RC情况下：
      - 查找tx不属于m_ids，且最大的tx_id，结果是tx_id=3，结果查出张飞
    - RR情况下：
      - 查找不属于m_ids，且最大的tx_id，结果是tx_id=0，结果查出刘备

  - T9时刻，发生第二次select语句，生成ReadView。

    - 系统中活跃的读写事务id列表m_ids：3
    - RC情况下：
      - 查找tx不属于m_ids，且最大的tx_id，结果是tx_id=5，结果查出诸葛亮
    - RR情况下：
      - 查找不属于m_ids，且最大的tx_id，结果是tx_id=0，结果查出刘备

# 题目 02- 什么是索引？

**要点：**

1. 优点是什么？
2. 缺点是什么？
3. 索引分类有哪些？特点是什么？
4. 索引创建的原则是什么？
5. 有哪些使用索引的注意事项？
6. 如何知道 SQL 是否用到了索引？
7. 请你解释一下索引的原理是什么？「重点」
   - 说清楚为什么要用 B+Tree

# 题目 03- 什么是 MVCC？

**要点：**

1. Redo 日志
2. ReadView
3. 如何判断可见性
# JVM 虚拟机论述题

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

堆：存放对象、数组、运行时常量的内存区域。

虚拟机栈：虚拟机执行Java字节码的栈

本地方法栈：虚拟机使用Native方法的栈

方法区：编译后代码的存储区域。包括类的类型信息、方法信息、字段信息、类变量、方法表，运行时常量池，JIT编译后的代码缓存。

永久代：JDK1.8之前的方法区实现。使用JVM的内存区域。存储上述所有方法区内容。

元空间：JDK1.8之后的方法区实现。使用系统物理内存区域。只存储类的元信息，静态变量和常量池放入堆中。

运行时常量池：一个Class对象有一个运行时常量池，存储字面量、符号引用。

字符串常量池：全局共用一个的存储字符串的常量池，使用StringTable，一种类似HashTable的数据结构。

直接内存：绕过JVM的内存区域直接操作系统内存地址，可以使用DirectByteBuffer进行操作，可以提升性能。

- 为什么堆内存要分年轻代和老年代？

这样可以按频次进行垃圾回收，提升垃圾回收效率，年轻代可以更频繁的垃圾回收，因为不会扫描老年代中回收概率低的内容，老年代可以低频次的垃圾回收。

题目 02- 描述一个 Java 对象的生命周期

- 解释一个对象的创建过程

  首先在常量池检查能否找到符号引用，如果找不到，或者找到了，但是未加载过，就加载类。若找到了，且已加载，就为对象分配内存空间、初始化内存空间、设置对象头、执行init方法。

- 解释一个对象的内存分配

  两种方式：Serial和ParNew收集器使用指针碰撞方式，CMS收集器和Mark-Sweep收集器使用空闲列表。指针碰撞，堆中内存是规整的，指针作为分界点指示器，一侧是所有被使用过的内存，另一侧是所有空闲的内存，分配内存时，移动指针即可。空闲列表，堆中内存不是规整的，虚拟机维护一个列表，记录哪些内存是可用的，分配时从列表中去查找空间。

- 解释一个对象的销毁过程

  垃圾回收（GC），释放不再使用的对象所占用的内存。释放前会执行finalize方法。

- 对象的 2 种访问方式是什么？

  句柄：通过引用类型的变量在堆的句柄池中找到该对象的句柄，句柄中有对象的地址；指针：引用类型的变量中直接存放对象地址，对象所在的内存空间需要能够存储类地址的信息。HotSpot使用指针引用。

- 为什么需要内存担保？

  新生代空间不足无法分配新对象，此时老年代还有空间，需要把新生代的老对象转移到老年代，腾出空间。

题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

算法：引用计数法，记录对象引用次数，引用+1、消失-1，减到0，认为是垃圾，无法解决循环引用问题。根可达算法：通过GCRoot的对象向下搜索，如果无法走到某个对象（走过的路径——引用链上没有某个对象），认为这个对象是垃圾。

- Serial：单线程、复制算法，没有线程交互开销，效率更高。
- SerialOld：Serial的老年代版本，“标记-整理”算法。

- ParNew 收集器：新生代并行，老年代串行（Serial Old）。
- ParallelScavenge 收集器：吞吐量优先。新生代使用并行回收收集器、复制算法，老年代使用串行收集器。
- ParallelOld 收集器：ParallelScavenge的老年代版本，使用多线程和“标记-整理”算法。CPU资源敏感，可以使用ParallelScavenge + ParallelOld算法。
- CMS 收集器：采用标记-清除算法，并发收集，减少STW（Stop the world）的影响，低延迟。会产生内存碎片，对CPU资源敏感。
- G1 收集器：并发收集。可以同时管理新生代和老年代。不会产生内存碎片。可以指定垃圾收集消耗的时间。专门划分了短期巨型对象的Humongous区。最小堆内存2GB。JDK1.7启用，JDK9以后的默认收集器。
- ZGC收集器：JDK11发布，JDK15稳定。并发、低延迟。
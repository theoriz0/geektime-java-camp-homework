# 题目 01：

一条 SQL 语句在 MySQL 中是如何执行的？

执行SQL语句前，需要连接到数据库上：通过连接命令。服务端通过连接器进行响应。

连接上之后：

1. （如果MySQL开启了缓存功能，并且语句没有声明禁用缓存；或者MySQL不显式禁用缓存，且语句声明使用缓存）查缓存：之前执行过的语句及 其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句hash之后的值，value 是查询的结果。
2. 分析SQL语句：把一个完整的 SQL 语句分割成一个个的字符串（词法分析）、判断是否满足 MySQL 语法（语法分析）、去检查解析树是否合法，比如表名是否存在，语句中表的列是否存 在、用户是否有表的操作权限等（预处理器）。
3. SQL语句优化：优化器选择Explain后执行计划成本最小的语句。（可以作为辅助，但是不能依赖此功能，要自己写高性能SQL）
4. 调用引擎，执行SQL语句
5. Select为例：
   1. 首先评估Join：形成一个临时表，包含所有满足ON条件的合并行
   1. 查询Where条件
   1. Group By
   1. Having
   1. Select 选择出需要的列
   1. Order By进行排序
6. Insert为例：
   1. 开启事务
   2. 添加锁
   3. 记录Undo、Redo日志
   4. 更新内存页
   5. 提交事务、Redo日志落盘
   6. 释放锁

7. 结果发回客户端

# 题目 02

请解释一下你理解的事务是什么？

## 数据库事务具有ACID四大特性。

- ACID是以下4个词的缩写： 原子性（Atomicity）： 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生， 要么都不发生。
-  一致性（Consistency）： 事务前后数据的完整性必须保持一致 
- 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干 扰，多个并发事务之间数据要相互隔离。隔离性由隔离级别保障！ 
- 持久性（Durability）： 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即 使数据库发生故障也不应该对其有任何影响。

## 事务会产生的并发问题

- 丢失更新：一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。
- 脏读：一个事务读到了另一个事务未提交的数据
- 不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发事务中的多次查询结果不一致
- 虚读 /幻读：一个事务读到了另一个事务已经插入(insert)的数据。导致事务中多次查询的结果不一致

## 事务隔离级别

- read uncommitted 读未提交，一个事务读到另一个事务没有提交的数据
- read committed 读已提交，一个事务读到另一个事务已经提交的数据
- repeatable read 可重复读，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交。
- serializable 串行化，同时只能执行一个事务，相当于事务中的单线程

## 事务的安全性、性能与隔离级别的关系

| 隔离级别           | 丢失更新 | 脏读   | 不可重复读 | 幻读   | 性能 | 安全性 |
| ------------------ | -------- | ------ | ---------- | ------ | ---- | ------ |
| RU读未提交         | 已解决   | 存在   | 存在       | 存在   | No.1 | No.4   |
| RC读已提交         | 已解决   | 已解决 | 存在       | 存在   | No.2 | No.3   |
| RR可重复读         | 已解决   | 已解决 | 已解决     | 已解决 | No.3 | No.2   |
| Serializable串行化 | 已解决   | 已解决 | 已解决     | 已解决 | No.4 | No.1   |

MySql 默认采用repeatable read；Oracle默认采用read committed。